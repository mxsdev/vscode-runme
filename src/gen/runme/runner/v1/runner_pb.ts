// @generated by protoc-gen-es v1.0.0 with parameter "target=ts"
// @generated from file runme/runner/v1/runner.proto (package runme.runner.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, UInt32Value } from "@bufbuild/protobuf";

/**
 * @generated from message runme.runner.v1.Session
 */
export class Session extends Message<Session> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: repeated string envs = 2;
   */
  envs: string[] = [];

  /**
   * @generated from field: map<string, string> metadata = 3;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Session>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.Session";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "envs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Session {
    return new Session().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Session {
    return new Session().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Session {
    return new Session().fromJsonString(jsonString, options);
  }

  static equals(a: Session | PlainMessage<Session> | undefined, b: Session | PlainMessage<Session> | undefined): boolean {
    return proto3.util.equals(Session, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.CreateSessionRequest
 */
export class CreateSessionRequest extends Message<CreateSessionRequest> {
  /**
   * @generated from field: map<string, string> metadata = 1;
   */
  metadata: { [key: string]: string } = {};

  /**
   * @generated from field: repeated string envs = 2;
   */
  envs: string[] = [];

  constructor(data?: PartialMessage<CreateSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.CreateSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "envs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSessionRequest {
    return new CreateSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSessionRequest {
    return new CreateSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSessionRequest {
    return new CreateSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSessionRequest | PlainMessage<CreateSessionRequest> | undefined, b: CreateSessionRequest | PlainMessage<CreateSessionRequest> | undefined): boolean {
    return proto3.util.equals(CreateSessionRequest, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.CreateSessionResponse
 */
export class CreateSessionResponse extends Message<CreateSessionResponse> {
  /**
   * @generated from field: runme.runner.v1.Session session = 1;
   */
  session?: Session;

  constructor(data?: PartialMessage<CreateSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.CreateSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "message", T: Session },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSessionResponse {
    return new CreateSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSessionResponse {
    return new CreateSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSessionResponse {
    return new CreateSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSessionResponse | PlainMessage<CreateSessionResponse> | undefined, b: CreateSessionResponse | PlainMessage<CreateSessionResponse> | undefined): boolean {
    return proto3.util.equals(CreateSessionResponse, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.GetSessionRequest
 */
export class GetSessionRequest extends Message<GetSessionRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.GetSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSessionRequest {
    return new GetSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSessionRequest {
    return new GetSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSessionRequest {
    return new GetSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSessionRequest | PlainMessage<GetSessionRequest> | undefined, b: GetSessionRequest | PlainMessage<GetSessionRequest> | undefined): boolean {
    return proto3.util.equals(GetSessionRequest, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.GetSessionResponse
 */
export class GetSessionResponse extends Message<GetSessionResponse> {
  /**
   * @generated from field: runme.runner.v1.Session session = 1;
   */
  session?: Session;

  constructor(data?: PartialMessage<GetSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.GetSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "message", T: Session },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSessionResponse {
    return new GetSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSessionResponse {
    return new GetSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSessionResponse {
    return new GetSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSessionResponse | PlainMessage<GetSessionResponse> | undefined, b: GetSessionResponse | PlainMessage<GetSessionResponse> | undefined): boolean {
    return proto3.util.equals(GetSessionResponse, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.ListSessionsRequest
 */
export class ListSessionsRequest extends Message<ListSessionsRequest> {
  constructor(data?: PartialMessage<ListSessionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.ListSessionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSessionsRequest {
    return new ListSessionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSessionsRequest {
    return new ListSessionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSessionsRequest {
    return new ListSessionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSessionsRequest | PlainMessage<ListSessionsRequest> | undefined, b: ListSessionsRequest | PlainMessage<ListSessionsRequest> | undefined): boolean {
    return proto3.util.equals(ListSessionsRequest, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.ListSessionsResponse
 */
export class ListSessionsResponse extends Message<ListSessionsResponse> {
  /**
   * @generated from field: repeated runme.runner.v1.Session sessions = 1;
   */
  sessions: Session[] = [];

  constructor(data?: PartialMessage<ListSessionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.ListSessionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sessions", kind: "message", T: Session, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSessionsResponse {
    return new ListSessionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSessionsResponse {
    return new ListSessionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSessionsResponse {
    return new ListSessionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSessionsResponse | PlainMessage<ListSessionsResponse> | undefined, b: ListSessionsResponse | PlainMessage<ListSessionsResponse> | undefined): boolean {
    return proto3.util.equals(ListSessionsResponse, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.DeleteSessionRequest
 */
export class DeleteSessionRequest extends Message<DeleteSessionRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.DeleteSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSessionRequest {
    return new DeleteSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSessionRequest {
    return new DeleteSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSessionRequest {
    return new DeleteSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSessionRequest | PlainMessage<DeleteSessionRequest> | undefined, b: DeleteSessionRequest | PlainMessage<DeleteSessionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSessionRequest, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.DeleteSessionResponse
 */
export class DeleteSessionResponse extends Message<DeleteSessionResponse> {
  constructor(data?: PartialMessage<DeleteSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.DeleteSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSessionResponse {
    return new DeleteSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSessionResponse {
    return new DeleteSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSessionResponse {
    return new DeleteSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSessionResponse | PlainMessage<DeleteSessionResponse> | undefined, b: DeleteSessionResponse | PlainMessage<DeleteSessionResponse> | undefined): boolean {
    return proto3.util.equals(DeleteSessionResponse, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.ExecuteRequest
 */
export class ExecuteRequest extends Message<ExecuteRequest> {
  /**
   * program_name is a name of the program to execute.
   * If it's not a path (relative or absolute), the runner
   * will try to resolve the name.
   * For example: "sh", "/bin/bash".
   *
   * @generated from field: string program_name = 1;
   */
  programName = "";

  /**
   * arguments is a list of arguments passed to the program.
   *
   * @generated from field: repeated string arguments = 2;
   */
  arguments: string[] = [];

  /**
   * directory to execute the program in.
   *
   * @generated from field: string directory = 3;
   */
  directory = "";

  /**
   * envs is a list of additional environment variables
   * that will be injected to the executed program.
   *
   * @generated from field: repeated string envs = 4;
   */
  envs: string[] = [];

  /**
   * commands are commands to be executed by the program.
   * The commands are joined and executed as a script.
   * For example: "echo 'Hello, World'", "ls -l /etc".
   * This is mutually exclusive with the script field.
   *
   * @generated from field: repeated string commands = 5;
   */
  commands: string[] = [];

  /**
   * script is code to be executed by the program.
   * Individual lines are joined with the new line character.
   * This is mutually exclusive with the commands field.
   *
   * @generated from field: string script = 6;
   */
  script = "";

  /**
   * tty when true allocates a pseudo-TTY.
   *
   * @generated from field: bool tty = 7;
   */
  tty = false;

  /**
   * background, if true, will not accept any input.
   *
   * @generated from field: bool background = 8;
   */
  background = false;

  /**
   * chunk_interval specifies how often partial output
   * should be streamed to the client.
   * For example: "0.5s".
   *
   * @generated from field: google.protobuf.Duration chunk_interval = 9;
   */
  chunkInterval?: Duration;

  /**
   * input_data is a byte array that will be send as input
   * to the program.
   * It is allowed in the consecutive calls only.
   *
   * @generated from field: bytes input_data = 10;
   */
  inputData = new Uint8Array(0);

  /**
   * session_id indicates in which Session the program should execute.
   * Executing in a Session might provide additional context like
   * environment variables.
   *
   * @generated from field: string session_id = 20;
   */
  sessionId = "";

  constructor(data?: PartialMessage<ExecuteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.ExecuteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "program_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "arguments", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "directory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "envs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "commands", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "tty", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "background", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "chunk_interval", kind: "message", T: Duration },
    { no: 10, name: "input_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 20, name: "session_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteRequest {
    return new ExecuteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteRequest {
    return new ExecuteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteRequest {
    return new ExecuteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined, b: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined): boolean {
    return proto3.util.equals(ExecuteRequest, a, b);
  }
}

/**
 * @generated from message runme.runner.v1.ExecuteResponse
 */
export class ExecuteResponse extends Message<ExecuteResponse> {
  /**
   * exit_code is sent only in the final message.
   *
   * @generated from field: google.protobuf.UInt32Value exit_code = 1;
   */
  exitCode?: number;

  /**
   * stdout_data contains bytes from stdout since the last response.
   *
   * @generated from field: bytes stdout_data = 2;
   */
  stdoutData = new Uint8Array(0);

  /**
   * stderr_data contains bytes from stderr since the last response.
   *
   * @generated from field: bytes stderr_data = 3;
   */
  stderrData = new Uint8Array(0);

  constructor(data?: PartialMessage<ExecuteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "runme.runner.v1.ExecuteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exit_code", kind: "message", T: UInt32Value },
    { no: 2, name: "stdout_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "stderr_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteResponse {
    return new ExecuteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteResponse {
    return new ExecuteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteResponse {
    return new ExecuteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined, b: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined): boolean {
    return proto3.util.equals(ExecuteResponse, a, b);
  }
}
